{
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "user-stories",
        "responseMode": "responseNode",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [-640, 240],
      "id": "webhook-us",
      "name": "Webhook User Stories",
      "webhookId": "us-generator"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "field1",
              "name": "analysis_id",
              "value": "={{ $json.body.analysis_id }}",
              "type": "string"
            },
            {
              "id": "field2",
              "name": "request_id",
              "value": "={{ $json.body.request_id }}",
              "type": "string"
            },
            {
              "id": "field3",
              "name": "cadrage_id",
              "value": "={{ $json.body.cadrage_id }}",
              "type": "string"
            },
            {
              "id": "field4",
              "name": "request_text",
              "value": "={{ $json.body.request_text }}",
              "type": "string"
            },
            {
              "id": "field5",
              "name": "complexity",
              "value": "={{ $json.body.complexity }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [-440, 240],
      "id": "keep-input-us",
      "name": "Keep Input Data"
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.cadrage_id }}",
              "operation": "isNotEmpty"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [-240, 240],
      "id": "check-cadrage-exists",
      "name": "Has Cadrage?"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT project_cadrage FROM maestro.projects WHERE id = (SELECT project_id FROM maestro.analyses WHERE id = $1::uuid)",
        "options": {
          "queryReplacement": "={{ $('Keep Input Data').item.json.analysis_id }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [-40, 120],
      "id": "fetch-project-cadrage",
      "name": "Fetch Project Cadrage",
      "credentials": {
        "postgres": {
          "id": "TxOzBdadKcgasYEn",
          "name": "MAESTRO DB"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "field1",
              "name": "cadrage_info",
              "value": "=Pas de cadrage disponible - Génération basée uniquement sur la demande",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [-40, 360],
      "id": "no-cadrage",
      "name": "No Cadrage"
    },
    {
      "parameters": {
        "jsCode": "// Fusionner les donnees pour Gemini\nconst inputData = $('Keep Input Data').first().json;\nlet cadrageInfo = 'Pas de cadrage disponible';\n\n// Si le projet a un cadrage, l extraire\nif ($('Fetch Project Cadrage').all().length > 0) {\n  const projectData = $('Fetch Project Cadrage').first().json;\n  if (projectData.project_cadrage) {\n    const cadrage = projectData.project_cadrage;\n    cadrageInfo = '\\nPerimetre: ' + JSON.stringify(cadrage.perimetre, null, 2) + '\\nArchitecture proposee: ' + JSON.stringify(cadrage.architecture, null, 2) + '\\nEstimation: ' + (cadrage.estimation?.effort_jours || 'N/A') + ' jours\\n';\n  }\n}\n\nreturn [{\n  json: {\n    request_text: inputData.request_text,\n    complexity: inputData.complexity,\n    cadrage_info: cadrageInfo,\n    analysis_id: inputData.analysis_id,\n    cadrage_id: inputData.cadrage_id || null\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [160, 240],
      "id": "merge-data-us",
      "name": "Merge Data for Gemini"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-lite:generateContent?key=AIzaSyCh8UXpXbf_E-NtkJC5QbMmbUpRw2zKN1M",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": 'Tu es le Product Owner de MAESTRO, expert en redaction de User Stories Agile.\\n\\n=== DEMANDE SPECIFIQUE A IMPLEMENTER ===\\n' + $json.request_text.replace(/\"/g, \"'\").replace(/\\n/g, \" \") + '\\n\\nComplexite estimee: ' + $json.complexity + '\\n\\n=== CONTEXTE TECHNIQUE DU PROJET (à utiliser UNIQUEMENT pour les contraintes techniques, pas pour ajouter des fonctionnalites) ===\\n' + $json.cadrage_info.replace(/\"/g, \"'\").replace(/\\n/g, \" \") + '\\n\\n⚠️ IMPORTANT: Tu dois generer des User Stories UNIQUEMENT pour la demande specifique ci-dessus. N ajoute PAS de fonctionnalites qui ne sont pas directement liees a cette demande. Le contexte technique sert uniquement a connaitre les contraintes (technologies, architecture, securite) mais PAS a definir le scope fonctionnel.\\n\\nMission:\\n1. Decomposer LA DEMANDE SPECIFIQUE en User Stories atomiques (1-5 jours max chacune)\\n2. Rester STRICTEMENT dans le perimetre de la demande\\n3. Format: En tant que [persona]... Je veux [action]... Afin de [benefice]...\\n4. Criteres acceptation en format Gherkin (Given/When/Then)\\n5. Estimation en story points (Fibonacci: 1,2,3,5,8,13)\\n6. Priorisation MoSCoW (MUST/SHOULD/COULD/WONT)\\n7. Identifier les dependances entre stories\\n8. Proposer une organisation en sprints\\n\\nExemple: Si la demande est Creer une page de CGV, tu dois generer des stories comme:\\n- US-001: Creer la structure HTML de la page CGV\\n- US-002: Rediger le contenu legal des CGV\\n- US-003: Ajouter le versioning des CGV\\nMAIS PAS des stories sur l authentification, la gestion utilisateurs, etc.\\n\\nReponds UNIQUEMENT en JSON avec cette structure exacte (pas de texte avant ou apres le JSON):\\n{\\n  \"epic\": {\\n    \"title\": \"Titre epic principal base sur la demande\",\\n    \"goal\": \"Objectif business mesurable\"\\n  },\\n  \"stories\": [\\n    {\\n      \"id\": \"US-001\",\\n      \"title\": \"Titre court et explicite\",\\n      \"as_a\": \"type utilisateur/persona\",\\n      \"i_want\": \"action/fonctionnalite souhaitee\",\\n      \"so_that\": \"benefice/valeur attendue\",\\n      \"acceptance_criteria\": [\\n        \"GIVEN [contexte initial] WHEN [action utilisateur] THEN [resultat attendu]\",\\n        \"GIVEN [autre contexte] WHEN [autre action] THEN [autre resultat]\"\\n      ],\\n      \"story_points\": 3,\\n      \"priority\": \"MUST\",\\n      \"dependencies\": [\"US-XXX\"],\\n      \"technical_notes\": \"Notes pour les developpeurs\",\\n      \"test_scenarios\": [\"Scenario de test 1\", \"Scenario de test 2\"]\\n    }\\n  ],\\n  \"sprint_suggestion\": {\\n    \"sprint_1\": {\\n      \"stories\": [\"US-001\", \"US-002\"],\\n      \"points\": 13,\\n      \"goal\": \"Objectif du sprint\"\\n    },\\n    \"sprint_2\": {\\n      \"stories\": [\"US-003\", \"US-004\"],\\n      \"points\": 15,\\n      \"goal\": \"Objectif du sprint\"\\n    },\\n    \"velocity_recommandee\": 20\\n  },\\n  \"metrics\": {\\n    \"total_points\": 45,\\n    \"must_have_points\": 25,\\n    \"should_have_points\": 15,\\n    \"could_have_points\": 5,\\n    \"estimated_sprints\": 3\\n  }\\n}'\n    }]\n  }],\n  \"generationConfig\": {\n    \"temperature\": 0.7,\n    \"topK\": 40,\n    \"topP\": 0.95,\n    \"maxOutputTokens\": 4096,\n    \"responseMimeType\": \"application/json\"\n  }\n} }}",
        "options": {
          "timeout": 90000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [360, 240],
      "id": "gemini-us",
      "name": "Gemini US Generation"
    },
    {
      "parameters": {
        "jsCode": "// Parser la reponse Gemini et preparer une ligne par story\nconst geminiResponse = $input.first().json;\nconst mergedData = $('Merge Data for Gemini').first().json;\n\nconsole.log('=== AGENT USER STORIES ===');\nconsole.log('Analysis ID:', mergedData.analysis_id);\n\nlet userStories = {};\ntry {\n  const textContent = geminiResponse.candidates[0].content.parts[0].text;\n  userStories = JSON.parse(textContent);\n  console.log('OK ' + (userStories.stories?.length || 0) + ' User Stories generees');\n  console.log('Total points:', userStories.metrics?.total_points || 0);\n} catch(e) {\n  console.error('ERROR Erreur parsing Gemini:', e.message);\n  userStories = {\n    epic: { title: 'Erreur de parsing', goal: 'N/A' },\n    stories: [],\n    metrics: { total_points: 0 }\n  };\n}\n\n// Preparer un item par story pour insertion en DB\nconst stories = userStories.stories || [];\nconst results = stories.map(story => ({\n  analysis_id: mergedData.analysis_id,\n  cadrage_id: mergedData.cadrage_id || null,\n  story_id: story.id,\n  title: story.title,\n  as_a: story.as_a,\n  i_want: story.i_want,\n  so_that: story.so_that,\n  priority: story.priority || 'SHOULD',\n  story_points: story.story_points || 0,\n  acceptance_criteria: JSON.stringify(story.acceptance_criteria || []),\n  test_scenarios: JSON.stringify(story.test_scenarios || []),\n  technical_notes: story.technical_notes || '',\n  dependencies: JSON.stringify(story.dependencies || [])\n}));\n\nconsole.log('Prepared ' + results.length + ' stories for DB insertion');\n\nreturn results.map(r => ({ json: r }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [560, 240],
      "id": "prepare-us-data",
      "name": "Prepare US Data (One Row Per Story)"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO maestro.user_stories (\n  analysis_id,\n  cadrage_id,\n  story_id,\n  title,\n  as_a,\n  i_want,\n  so_that,\n  priority,\n  story_points,\n  acceptance_criteria,\n  test_scenarios,\n  technical_notes,\n  dependencies,\n  status\n) VALUES (\n  $1::uuid,\n  $2::uuid,\n  $3,\n  $4,\n  $5,\n  $6,\n  $7,\n  $8,\n  $9,\n  $10::jsonb,\n  $11::jsonb,\n  $12,\n  $13::jsonb,\n  'PENDING'\n) RETURNING id, story_id, created_at;",
        "options": {
          "queryReplacement": "={{ [\n  $json.analysis_id,\n  $json.cadrage_id,\n  $json.story_id,\n  $json.title,\n  $json.as_a,\n  $json.i_want,\n  $json.so_that,\n  $json.priority,\n  $json.story_points,\n  $json.acceptance_criteria,\n  $json.test_scenarios,\n  $json.technical_notes,\n  $json.dependencies\n] }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [760, 240],
      "id": "save-us",
      "name": "Save Each User Story (Loop)",
      "credentials": {
        "postgres": {
          "id": "TxOzBdadKcgasYEn",
          "name": "MAESTRO DB"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Aggreger les resultats de toutes les insertions\nconst insertions = $input.all();\nconst analysis_id = insertions[0]?.json?.analysis_id || 'unknown';\n\nconst storyIds = insertions.map(i => i.json.story_id);\nconst totalStories = insertions.length;\nconst firstCreatedAt = insertions[0]?.json?.created_at;\n\nconsole.log('Successfully inserted ' + totalStories + ' user stories');\n\nreturn [{\n  json: {\n    status: 'success',\n    agent: 'US',\n    message: totalStories + ' User Stories créées avec succès',\n    analysis_id: analysis_id,\n    total_stories: totalStories,\n    story_ids: storyIds,\n    created_at: firstCreatedAt\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [960, 240],
      "id": "aggregate-results",
      "name": "Aggregate Results"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json, null, 2) }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [1160, 240],
      "id": "respond-us",
      "name": "Respond Success"
    }
  ],
  "connections": {
    "Webhook User Stories": {
      "main": [[{"node": "Keep Input Data", "type": "main", "index": 0}]]
    },
    "Keep Input Data": {
      "main": [[{"node": "Has Cadrage?", "type": "main", "index": 0}]]
    },
    "Has Cadrage?": {
      "main": [
        [{"node": "Fetch Project Cadrage", "type": "main", "index": 0}],
        [{"node": "No Cadrage", "type": "main", "index": 0}]
      ]
    },
    "Fetch Project Cadrage": {
      "main": [[{"node": "Merge Data for Gemini", "type": "main", "index": 0}]]
    },
    "No Cadrage": {
      "main": [[{"node": "Merge Data for Gemini", "type": "main", "index": 0}]]
    },
    "Merge Data for Gemini": {
      "main": [[{"node": "Gemini US Generation", "type": "main", "index": 0}]]
    },
    "Gemini US Generation": {
      "main": [[{"node": "Prepare US Data (One Row Per Story)", "type": "main", "index": 0}]]
    },
    "Prepare US Data (One Row Per Story)": {
      "main": [[{"node": "Save Each User Story (Loop)", "type": "main", "index": 0}]]
    },
    "Save Each User Story (Loop)": {
      "main": [[{"node": "Aggregate Results", "type": "main", "index": 0}]]
    },
    "Aggregate Results": {
      "main": [[{"node": "Respond Success", "type": "main", "index": 0}]]
    }
  },
  "pinData": {},
  "meta": {
    "instanceId": "ed02db89d7f2488035bfec7b1491988dab1d203f160701f703954ad6afe22be8"
  }
}
